---
title: "å®Ÿè·µçš„ãªãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹é–‹ç™ºã‚¬ã‚¤ãƒ‰ 2025å¹´ç‰ˆ"
emoji: "ğŸ”„"
type: "tech"
topics: ["ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹", "ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£", "APIè¨­è¨ˆ", "ã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆ", "Kubernetes"]
published: false
---

# å®Ÿè·µçš„ãªãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹é–‹ç™ºã‚¬ã‚¤ãƒ‰ 2025å¹´ç‰ˆ
:::message
This article is generated by Claude.
:::
## ã¯ã˜ã‚ã«

ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã¯ã€å¤šãã®ä¼æ¥­ãŒã‚·ã‚¹ãƒ†ãƒ é–‹ç™ºã®ä¸»è¦ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¨ã—ã¦æ¡ç”¨ã—ã¦ã„ã¾ã™ã€‚ã—ã‹ã—ã€ãã®å®Ÿè£…ã¯ç†è«–ã‚ˆã‚Šã‚‚å®Ÿè·µãŒé›£ã—ã„ã‚‚ã®ã§ã™ã€‚æœ¬è¨˜äº‹ã§ã¯ã€2025å¹´ã®é–‹ç™ºç’°å¢ƒã‚’è¸ã¾ãˆãŸå®Ÿè·µçš„ãªãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹é–‹ç™ºã®ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã‚’æä¾›ã—ã¾ã™ã€‚è¨­è¨ˆã‹ã‚‰å®Ÿè£…ã€é‹ç”¨ã¾ã§ã®ä¸€é€£ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã‚’è§£èª¬ã—ã€å®Ÿéš›ã®é–‹ç™ºç¾å ´ã§ç›´é¢ã™ã‚‹èª²é¡Œã¸ã®å¯¾å‡¦æ³•ã‚‚ç´¹ä»‹ã—ã¾ã™ã€‚

## ç›®æ¬¡

1. [ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®ç¾çŠ¶](#ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®ç¾çŠ¶)
2. [åŠ¹æœçš„ãªã‚µãƒ¼ãƒ“ã‚¹åˆ†å‰²æˆ¦ç•¥](#åŠ¹æœçš„ãªã‚µãƒ¼ãƒ“ã‚¹åˆ†å‰²æˆ¦ç•¥)
3. [é€šä¿¡ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨APIè¨­è¨ˆ](#é€šä¿¡ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨apiè¨­è¨ˆ)
4. [ãƒ‡ãƒ¼ã‚¿ç®¡ç†ã¨æ•´åˆæ€§](#ãƒ‡ãƒ¼ã‚¿ç®¡ç†ã¨æ•´åˆæ€§)
5. [ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆã¨ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³](#ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆã¨ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³)
6. [ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã¨å¯è¦³æ¸¬æ€§](#ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã¨å¯è¦³æ¸¬æ€§)
7. [éšœå®³å¯¾å¿œã¨å›å¾©åŠ›](#éšœå®³å¯¾å¿œã¨å›å¾©åŠ›)
8. [ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã®é€²åŒ–ã¨ä¿å®ˆ](#ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã®é€²åŒ–ã¨ä¿å®ˆ)
9. [ã¾ã¨ã‚](#ã¾ã¨ã‚)

## ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®ç¾çŠ¶

ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã¯éå»æ•°å¹´é–“ã§æˆç†Ÿã—ã€å¤šãã®ä¼æ¥­ãŒæ¡ç”¨ã™ã‚‹ãƒ‡ãƒ•ã‚¡ã‚¯ãƒˆã‚¹ã‚¿ãƒ³ãƒ€ãƒ¼ãƒ‰ã¨ãªã‚Šã¾ã—ãŸã€‚2025å¹´ç¾åœ¨ã€ä»¥ä¸‹ã®ãƒˆãƒ¬ãƒ³ãƒ‰ãŒé¡•è‘—ã«ãªã£ã¦ã„ã¾ã™ã€‚

### ç¾ä»£ã®ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ä¸»è¦ãƒˆãƒ¬ãƒ³ãƒ‰

1. **ã‚µãƒ¼ãƒ“ã‚¹ãƒ¡ãƒƒã‚·ãƒ¥ã®æ¨™æº–åŒ–**: Istioã‚„Linkerdãªã©ã®ã‚µãƒ¼ãƒ“ã‚¹ãƒ¡ãƒƒã‚·ãƒ¥æŠ€è¡“ãŒæ¨™æº–è£…å‚™ã¨ãªã‚Šã€é€šä¿¡ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã¨ä¿¡é ¼æ€§ãŒå‘ä¸Š
2. **ã‚µãƒ¼ãƒãƒ¼ãƒ¬ã‚¹ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹**: å¾“æ¥ã®ã‚³ãƒ³ãƒ†ãƒŠå‹ã‚µãƒ¼ãƒ“ã‚¹ã¨ã‚µãƒ¼ãƒãƒ¼ãƒ¬ã‚¹é–¢æ•°ã®èåˆãŒé€²è¡Œ
3. **Polyglotã‹ã‚‰Monoglotã¸ã®å›å¸°**: è¨€èªå¤šæ§˜æ€§ã‚ˆã‚Šã‚‚é–‹ç™ºåŠ¹ç‡ã¨ä¿å®ˆæ€§ã‚’é‡è¦–ã™ã‚‹å‚¾å‘
4. **å†…éƒ¨é–‹ç™ºè€…ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ (IDP)**: ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹é–‹ç™ºã®ãŸã‚ã®ç¤¾å†…PaaSã®æ§‹ç¯‰

### ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã®æˆç†Ÿåº¦ãƒ¢ãƒ‡ãƒ«

ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã®çµ„ç¹”çš„æˆç†Ÿåº¦ã¯ä»¥ä¸‹ã®5æ®µéšã§è©•ä¾¡ã§ãã¾ã™ï¼š

| ãƒ¬ãƒ™ãƒ« | æ®µéšå | ç‰¹å¾´ |
|--------|--------|------|
| ãƒ¬ãƒ™ãƒ«0 | ãƒ¢ãƒãƒªã‚·ãƒƒã‚¯ | å¾“æ¥å‹ã®å˜ä¸€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ |
| ãƒ¬ãƒ™ãƒ«1 | åˆ†é›¢å‹ | åŸºæœ¬çš„ãªã‚µãƒ¼ãƒ“ã‚¹åˆ†é›¢ã€æ‰‹å‹•ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆ |
| ãƒ¬ãƒ™ãƒ«2 | èª¿æ•´å‹ | CI/CDãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã€åŸºæœ¬çš„ãªã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ |
| ãƒ¬ãƒ™ãƒ«3 | è‡ªå‹•åŒ–å‹ | ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆè‡ªå‹•åŒ–ã€åŸºæœ¬çš„ãªå¯è¦³æ¸¬æ€§ |
| ãƒ¬ãƒ™ãƒ«4 | è‡ªå·±æœ€é©åŒ–å‹ | ã‚«ã‚ªã‚¹ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°ã€è‡ªå‹•ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚° |
| ãƒ¬ãƒ™ãƒ«5 | è‡ªå¾‹é€²åŒ–å‹ | AIã«ã‚ˆã‚‹æœ€é©åŒ–ã€è‡ªå·±ä¿®å¾©ã‚·ã‚¹ãƒ†ãƒ  |

ç¾åœ¨ã€å¤šãã®ä¼æ¥­ã¯ãƒ¬ãƒ™ãƒ«3ã‹ã‚‰ãƒ¬ãƒ™ãƒ«4ã¸ã®ç§»è¡Œæ®µéšã«ã‚ã‚Šã¾ã™ã€‚

## åŠ¹æœçš„ãªã‚µãƒ¼ãƒ“ã‚¹åˆ†å‰²æˆ¦ç•¥

é©åˆ‡ãªã‚µãƒ¼ãƒ“ã‚¹åˆ†å‰²ã¯ã€ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®æˆåŠŸã«ä¸å¯æ¬ ã§ã™ã€‚

### ãƒ‰ãƒ¡ã‚¤ãƒ³é§†å‹•è¨­è¨ˆ(DDD)ã®å®Ÿè·µ

ãƒ“ã‚¸ãƒã‚¹ãƒ‰ãƒ¡ã‚¤ãƒ³ã«åŸºã¥ã„ãŸã‚µãƒ¼ãƒ“ã‚¹åˆ†å‰²ã®ä¾‹ï¼š

```typescript
// ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‰ãƒ¡ã‚¤ãƒ³ã®ã‚³ã‚¢ãƒ¢ãƒ‡ãƒ«
export class User {
  private readonly id: UserId;
  private email: Email;
  private profile: UserProfile;
  private preferences: UserPreferences;
  private readonly createdAt: Date;
  private updatedAt: Date;

  constructor(id: UserId, email: Email, profile: UserProfile) {
    this.id = id;
    this.email = email;
    this.profile = profile;
    this.preferences = new UserPreferences();
    this.createdAt = new Date();
    this.updatedAt = new Date();
  }

  // ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ­ã‚¸ãƒƒã‚¯ã‚’ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã—ã¦ã‚«ãƒ—ã‚»ãƒ«åŒ–
  updateEmail(newEmail: Email): void {
    this.email = newEmail;
    this.updatedAt = new Date();
    DomainEvents.publish(new UserEmailChangedEvent(this.id, newEmail));
  }
  
  // ... ä»–ã®ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ­ã‚¸ãƒƒã‚¯
}
```

### åˆ†å‰²ç²’åº¦ã®æ±ºå®šè¦å› 

ã‚µãƒ¼ãƒ“ã‚¹åˆ†å‰²ã®ç²’åº¦ã‚’æ±ºå®šã™ã‚‹éš›ã®è€ƒæ…®äº‹é …ï¼š

1. **ãƒãƒ¼ãƒ ã®æ§‹é€ ã¨è¦æ¨¡**: ã€Œ2ã¤ã®ãƒ”ã‚¶ãƒãƒ¼ãƒ ã€ã®åŸå‰‡
2. **ãƒ“ã‚¸ãƒã‚¹æ©Ÿèƒ½ã®ç‹¬ç«‹æ€§**: å¤‰æ›´ã®é »åº¦ã¨å½±éŸ¿ç¯„å›²
3. **æŠ€è¡“çš„ä¾å­˜é–¢ä¿‚**: å…±æœ‰ãƒªã‚½ãƒ¼ã‚¹ã¨ã‚¤ãƒ³ãƒ•ãƒ©è¦ä»¶
4. **ãƒ‡ãƒ¼ã‚¿ã®çµåˆåº¦**: ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å¢ƒç•Œã¨å‚ç…§æ•´åˆæ€§
5. **ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°è¦ä»¶**: å‡¦ç†è² è·ã¨ãƒªã‚½ãƒ¼ã‚¹æ¶ˆè²»ãƒ‘ã‚¿ãƒ¼ãƒ³

### ã‚µãƒ¼ãƒ“ã‚¹é–“ã®è²¬ä»»åˆ†æ‹…

åŠ¹æœçš„ãªã‚µãƒ¼ãƒ“ã‚¹åˆ†å‰²ã®ä¾‹ã¨ã—ã¦ã€ECã‚µã‚¤ãƒˆã‚’è€ƒãˆã¦ã¿ã¾ã—ã‚‡ã†ï¼š

| ã‚µãƒ¼ãƒ“ã‚¹å | ä¸»è¦è²¬ä»» | å¤–éƒ¨ä¾å­˜ |
|------------|----------|----------|
| User Service | ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼ã€ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ç®¡ç† | Identity Provider |
| Catalog Service | å•†å“æƒ…å ±ã€ã‚«ãƒ†ã‚´ãƒªã€æ¤œç´¢ | Content Delivery Network |
| Cart Service | ã‚·ãƒ§ãƒƒãƒ”ãƒ³ã‚°ã‚«ãƒ¼ãƒˆç®¡ç† | User Service, Catalog Service |
| Order Service | æ³¨æ–‡å‡¦ç†ã€å±¥æ­´ç®¡ç† | User Service, Cart Service, Payment Service |
| Payment Service | æ±ºæ¸ˆå‡¦ç†ã€æ”¯æ‰•ã„ç®¡ç† | å¤–éƒ¨æ±ºæ¸ˆã‚²ãƒ¼ãƒˆã‚¦ã‚§ã‚¤ |
| Recommendation Service | ãƒ‘ãƒ¼ã‚½ãƒŠãƒ©ã‚¤ã‚ºãƒ‰æ¨å¥¨ | Catalog Service, User Service, Analytics Service |

## é€šä¿¡ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨APIè¨­è¨ˆ

ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹é–“ã®é€šä¿¡ã¯ã€ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®æ€§èƒ½ã¨ä¿¡é ¼æ€§ã«å¤§ããªå½±éŸ¿ã‚’ä¸ãˆã¾ã™ã€‚

### åŒæœŸé€šä¿¡ã¨éåŒæœŸé€šä¿¡ã®é¸æŠ

é€šä¿¡ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ç‰¹æ€§æ¯”è¼ƒï¼š

| ç‰¹æ€§ | åŒæœŸé€šä¿¡ï¼ˆREST, gRPCï¼‰ | éåŒæœŸé€šä¿¡ï¼ˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ³ã‚°ï¼‰ |
|------|-------------------|-----------------------|
| ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“ | å³æ™‚ | é…å»¶ã‚ã‚Š |
| çµåˆåº¦ | å¼·ã„ï¼ˆæ™‚é–“çš„çµåˆï¼‰ | ç·©ã„ï¼ˆæ™‚é–“çš„åˆ†é›¢ï¼‰ |
| ä¿¡é ¼æ€§ | ã‚µãƒ¼ãƒ“ã‚¹ä¾å­˜ | é«˜ï¼ˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ°¸ç¶šåŒ–ï¼‰ |
| ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£ | åˆ¶é™ã‚ã‚Š | é«˜ã„ |
| å®Ÿè£…è¤‡é›‘ã• | ä½ã€œä¸­ | ä¸­ã€œé«˜ |
| ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ | ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ãƒ­ãƒ¼ã€ã‚¯ã‚¨ãƒª | ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å‡¦ç†ã€ã‚¤ãƒ™ãƒ³ãƒˆ |

### REST APIã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

RESTful APIã®è¨­è¨ˆä¾‹ï¼ˆOpenAPI 3.1å½¢å¼ï¼‰ï¼š

```yaml
openapi: 3.1.0
info:
  title: Order Service API
  version: 1.0.0
  description: ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã«ãŠã‘ã‚‹æ³¨æ–‡ç®¡ç†ã‚µãƒ¼ãƒ“ã‚¹API
paths:
  /orders:
    post:
      summary: æ–°è¦æ³¨æ–‡ã®ä½œæˆ
      operationId: createOrder
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/OrderRequest'
      responses:
        '201':
          description: æ³¨æ–‡ãŒæ­£å¸¸ã«ä½œæˆã•ã‚Œã¾ã—ãŸ
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Order'
        '400':
          $ref: '#/components/responses/BadRequest'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '403':
          $ref: '#/components/responses/Forbidden'
        '500':
          $ref: '#/components/responses/InternalError'
    get:
      summary: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æ³¨æ–‡ä¸€è¦§å–å¾—
      operationId: listOrders
      parameters:
        - name: userId
          in: query
          required: true
          schema:
            type: string
        - name: status
          in: query
          schema:
            type: string
            enum: [PENDING, PROCESSING, SHIPPED, DELIVERED, CANCELLED]
        - name: page
          in: query
          schema:
            type: integer
            default: 1
        - name: limit
          in: query
          schema:
            type: integer
            default: 20
      responses:
        '200':
          description: æ³¨æ–‡ãƒªã‚¹ãƒˆ
          content:
            application/json:
              schema:
                type: object
                properties:
                  items:
                    type: array
                    items:
                      $ref: '#/components/schemas/Order'
                  pagination:
                    $ref: '#/components/schemas/Pagination'
components:
  schemas:
    OrderRequest:
      type: object
      required:
        - userId
        - items
        - shippingAddress
      properties:
        userId:
          type: string
        items:
          type: array
          items:
            $ref: '#/components/schemas/OrderItem'
        shippingAddress:
          $ref: '#/components/schemas/Address'
        paymentInfo:
          $ref: '#/components/schemas/PaymentInfo'
    # ... ãã®ä»–ã®ã‚¹ã‚­ãƒ¼ãƒå®šç¾©
  responses:
    BadRequest:
      description: ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒä¸æ­£ã§ã™
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
    # ... ãã®ä»–ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹å®šç¾©
```

### ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•å‹ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã®å®Ÿè£…ä¾‹ï¼ˆAWS SNS/SQSï¼‰ï¼š

```typescript
// ã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œå´ï¼ˆPublisherï¼‰
import { SNS } from 'aws-sdk';

const sns = new SNS({ region: 'us-east-1' });

async function publishOrderCreatedEvent(order: Order): Promise<void> {
  const params = {
    TopicArn: 'arn:aws:sns:us-east-1:123456789012:order-events',
    Message: JSON.stringify({
      eventType: 'OrderCreated',
      version: '1.0',
      data: {
        orderId: order.id,
        userId: order.userId,
        totalAmount: order.totalAmount,
        timestamp: new Date().toISOString()
      }
    }),
    MessageAttributes: {
      eventType: {
        DataType: 'String',
        StringValue: 'OrderCreated'
      }
    }
  };

  try {
    await sns.publish(params).promise();
    console.log(`OrderCreated event published for order ${order.id}`);
  } catch (error) {
    console.error('Failed to publish OrderCreated event:', error);
    throw error;
  }
}

// ã‚¤ãƒ™ãƒ³ãƒˆå—ä¿¡å´ï¼ˆConsumerï¼‰
import { SQS } from 'aws-sdk';

const sqs = new SQS({ region: 'us-east-1' });

async function processOrderEvents(): Promise<void> {
  const params = {
    QueueUrl: 'https://sqs.us-east-1.amazonaws.com/123456789012/order-processing',
    MaxNumberOfMessages: 10,
    WaitTimeSeconds: 20
  };

  try {
    const data = await sqs.receiveMessage(params).promise();
    if (data.Messages) {
      for (const message of data.Messages) {
        try {
          const body = JSON.parse(message.Body || '{}');
          const snsMessage = JSON.parse(body.Message || '{}');
          
          if (snsMessage.eventType === 'OrderCreated') {
            await processOrderCreatedEvent(snsMessage.data);
          }
          
          // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‡¦ç†ã—ãŸã‚‰ã‚­ãƒ¥ãƒ¼ã‹ã‚‰å‰Šé™¤
          await sqs.deleteMessage({
            QueueUrl: params.QueueUrl,
            ReceiptHandle: message.ReceiptHandle || ''
          }).promise();
        } catch (processingError) {
          console.error('Error processing message:', processingError);
          // å¤±æ•—ã—ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å‡¦ç†ï¼ˆDLQãªã©ï¼‰
        }
      }
    }
  } catch (error) {
    console.error('Error receiving messages:', error);
  }
  
  // ç¶™ç¶šçš„ãªå‡¦ç†ï¼ˆå®Ÿéš›ã«ã¯ã‚µãƒ¼ãƒãƒ¼ãƒ¬ã‚¹é–¢æ•°ãªã©ã§ãƒˆãƒªã‚¬ãƒ¼ï¼‰
  setTimeout(processOrderEvents, 100);
}

async function processOrderCreatedEvent(data: any): Promise<void> {
  console.log(`Processing OrderCreated event for order ${data.orderId}`);
  // åœ¨åº«ç¢ºèªã€é…é€æº–å‚™ã€ãƒ¡ãƒ¼ãƒ«é€ä¿¡ãªã©
}
```

### API Gateway ãƒ‘ã‚¿ãƒ¼ãƒ³

ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’ä¸€å…ƒåŒ–ã™ã‚‹API Gatewayã®è¨­å®šä¾‹ï¼ˆKongï¼‰ï¼š

```yaml
# Kongå®£è¨€å‹è¨­å®š
services:
  - name: user-service
    url: http://user-service:8080
    routes:
      - name: user-api
        paths:
          - /api/users
        strip_path: false
        plugins:
          - name: rate-limiting
            config:
              second: 5
              hour: 1000
          - name: key-auth
          - name: cors
            config:
              origins:
                - '*'
              methods:
                - GET
                - POST
                - PUT
                - DELETE
  
  - name: order-service
    url: http://order-service:8080
    routes:
      - name: order-api
        paths:
          - /api/orders
        strip_path: false
        plugins:
          - name: jwt
          - name: request-transformer
            config:
              add:
                headers:
                  - X-Consumer-ID:$(consumer.id)
```

## ãƒ‡ãƒ¼ã‚¿ç®¡ç†ã¨æ•´åˆæ€§

ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã§ã®åŠ¹æœçš„ãªãƒ‡ãƒ¼ã‚¿ç®¡ç†æˆ¦ç•¥ã‚’æ¤œè¨ã—ã¾ã™ã€‚

### ãƒ‡ãƒ¼ã‚¿æ‰€æœ‰æ¨©ã¨ã‚¢ã‚¯ã‚»ã‚¹ãƒ‘ã‚¿ãƒ¼ãƒ³

ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã«ãŠã‘ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼š

1. **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¯ã‚µãƒ¼ãƒ“ã‚¹**: å„ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ãŒç‹¬è‡ªã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’æ‰€æœ‰
2. **ã‚¹ã‚­ãƒ¼ãƒæ¯ã‚µãƒ¼ãƒ“ã‚¹**: å…±æœ‰ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã§å„ã‚µãƒ¼ãƒ“ã‚¹ãŒå°‚ç”¨ã‚¹ã‚­ãƒ¼ãƒã‚’ä½¿ç”¨
3. **CQRSï¼ˆã‚³ãƒãƒ³ãƒ‰/ã‚¯ã‚¨ãƒªè²¬å‹™åˆ†é›¢ï¼‰**: æ›¸ãè¾¼ã¿ã¨èª­ã¿å–ã‚Šã®ãƒ¢ãƒ‡ãƒ«ã‚’åˆ†é›¢

ãƒ‡ãƒ¼ã‚¿ãƒã‚¦ãƒ³ãƒ€ãƒªãƒ¼ã®ä¾‹ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚µãƒ¼ãƒ“ã‚¹ã¨ã‚ªãƒ¼ãƒ€ãƒ¼ã‚µãƒ¼ãƒ“ã‚¹ï¼‰ï¼š

```typescript
// ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚µãƒ¼ãƒ“ã‚¹å†…ã®ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒ«
interface User {
  id: string;
  email: string;
  name: string;
  billingAddress: Address;
  shippingAddresses: Address[];
  preferences: UserPreferences;
  // ...ãã®ä»–ãƒ¦ãƒ¼ã‚¶ãƒ¼é–¢é€£ãƒ‡ãƒ¼ã‚¿
}

// ã‚ªãƒ¼ãƒ€ãƒ¼ã‚µãƒ¼ãƒ“ã‚¹å†…ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼å‚ç…§
interface OrderCustomer {
  id: string;  // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚µãƒ¼ãƒ“ã‚¹ã¸ã®å‚ç…§ã‚­ãƒ¼
  name: string; // æ³¨æ–‡æ™‚ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼åï¼ˆå†—é•·ãƒ‡ãƒ¼ã‚¿ï¼‰
  email: string; // æ³¨æ–‡æ™‚ã®ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ï¼ˆå†—é•·ãƒ‡ãƒ¼ã‚¿ï¼‰
  shippingAddress: Address; // æ³¨æ–‡æ™‚ã®é…é€å…ˆï¼ˆå†—é•·ãƒ‡ãƒ¼ã‚¿ï¼‰
  // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚µãƒ¼ãƒ“ã‚¹ã«å­˜åœ¨ã™ã‚‹ä»–ã®ãƒ‡ãƒ¼ã‚¿ã¯å‚ç…§ã—ãªã„
}

// ã“ã®è¨­è¨ˆã®ãƒã‚¤ãƒ³ãƒˆï¼š
// 1. ã‚ªãƒ¼ãƒ€ãƒ¼ã‚µãƒ¼ãƒ“ã‚¹ã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼å®Œå…¨ãƒ‡ãƒ¼ã‚¿ã§ã¯ãªãã€æ³¨æ–‡ã«å¿…è¦ãªæƒ…å ±ã®ã¿ã‚’ä¿æŒ
// 2. ãƒ‡ãƒ¼ã‚¿ã®ä¸€è²«æ€§ã‚ˆã‚Šã‚‚å¯ç”¨æ€§ã‚’å„ªå…ˆï¼ˆçµæœæ•´åˆæ€§ï¼‰
// 3. ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±æ›´æ–°ã¯ã‚¤ãƒ™ãƒ³ãƒˆã§ä¼æ’­ï¼ˆä¾‹ï¼šãƒ¦ãƒ¼ã‚¶ãƒ¼åå¤‰æ›´ã‚¤ãƒ™ãƒ³ãƒˆï¼‰
```

### ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒ‘ã‚¿ãƒ¼ãƒ³

ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹é–“ã®ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ã‚’ç¢ºä¿ã™ã‚‹ä¸»è¦ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼š

#### 1. Saga ãƒ‘ã‚¿ãƒ¼ãƒ³

è¤‡æ•°ã‚µãƒ¼ãƒ“ã‚¹ã«ã¾ãŸãŒã‚‹ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’è£œå„Ÿå¯èƒ½ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®é€£é–ã¨ã—ã¦å®Ÿè£…:

```typescript
// æ³¨æ–‡å‡¦ç†Sagaã®å®Ÿè£…ä¾‹ï¼ˆã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å‹ï¼‰
class OrderProcessingSaga {
  async execute(orderData: OrderData): Promise<void> {
    try {
      // ã‚¹ãƒ†ãƒƒãƒ—1: æ³¨æ–‡ã®ä½œæˆ
      const orderId = await this.orderService.createOrder(orderData);
      
      try {
        // ã‚¹ãƒ†ãƒƒãƒ—2: åœ¨åº«ã®ç¢ºä¿
        await this.inventoryService.reserveItems(orderData.items, orderId);
        
        try {
          // ã‚¹ãƒ†ãƒƒãƒ—3: æ”¯æ‰•ã„å‡¦ç†
          await this.paymentService.processPayment(
            orderData.paymentInfo, 
            orderData.totalAmount,
            orderId
          );
          
          try {
            // ã‚¹ãƒ†ãƒƒãƒ—4: é…é€æ‰‹é…
            await this.shippingService.scheduleDelivery(
              orderId,
              orderData.shippingAddress
            );
            
            // ã™ã¹ã¦æˆåŠŸï¼šæ³¨æ–‡ç¢ºå®š
            await this.orderService.confirmOrder(orderId);
          } catch (shippingError) {
            // é…é€æ‰‹é…ã®å¤±æ•—ã‚’è£œå„Ÿ
            await this.paymentService.refundPayment(orderId);
            await this.inventoryService.releaseItems(orderData.items, orderId);
            await this.orderService.cancelOrder(orderId);
            throw shippingError;
          }
        } catch (paymentError) {
          // æ”¯æ‰•ã„å‡¦ç†ã®å¤±æ•—ã‚’è£œå„Ÿ
          await this.inventoryService.releaseItems(orderData.items, orderId);
          await this.orderService.cancelOrder(orderId);
          throw paymentError;
        }
      } catch (inventoryError) {
        // åœ¨åº«ç¢ºä¿ã®å¤±æ•—ã‚’è£œå„Ÿ
        await this.orderService.cancelOrder(orderId);
        throw inventoryError;
      }
    } catch (error) {
      console.error('Order processing failed:', error);
      throw new Error(`Order processing failed: ${error.message}`);
    }
  }
}
```

#### 2. ã‚¤ãƒ™ãƒ³ãƒˆã‚½ãƒ¼ã‚·ãƒ³ã‚°ã¨CQRS

ã‚¤ãƒ™ãƒ³ãƒˆã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½¿ç”¨ã—ã¦ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ã‚’ç®¡ç†ã—ã€èª­ã¿å–ã‚Šã¨æ›¸ãè¾¼ã¿ã‚’åˆ†é›¢:

```typescript
// ã‚¤ãƒ™ãƒ³ãƒˆã‚¹ãƒˆã‚¢æŠ½è±¡åŒ–
interface Event {
  id: string;
  type: string;
  aggregateId: string;
  data: any;
  timestamp: Date;
}

class EventStore {
  async saveEvents(aggregateId: string, events: Event[]): Promise<void> {
    // ã‚¤ãƒ™ãƒ³ãƒˆã®æ°¸ç¶šåŒ–ï¼ˆä¾‹ï¼šãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã¸ã®ä¿å­˜ï¼‰
  }

  async getEvents(aggregateId: string): Promise<Event[]> {
    // ç‰¹å®šã®é›†ç´„ã«é–¢ã™ã‚‹ã‚¤ãƒ™ãƒ³ãƒˆã®å–å¾—
  }
}

// æ³¨æ–‡é›†ç´„ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚½ãƒ¼ã‚·ãƒ³ã‚°å®Ÿè£…
class Order {
  private id: string;
  private userId: string;
  private items: OrderItem[] = [];
  private status: OrderStatus = OrderStatus.CREATED;
  private totalAmount: number = 0;
  
  // æœªé©ç”¨ã‚¤ãƒ™ãƒ³ãƒˆã®ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°
  private pendingEvents: Event[] = [];
  
  // çŠ¶æ…‹å†æ§‹ç¯‰
  static async load(id: string, eventStore: EventStore): Promise<Order> {
    const events = await eventStore.getEvents(id);
    const order = new Order(id);
    
    // ä¿å­˜ã•ã‚Œã¦ã„ã‚‹ã™ã¹ã¦ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’é©ç”¨
    for (const event of events) {
      order.apply(event, false);
    }
    
    return order;
  }
  
  constructor(id: string) {
    this.id = id;
  }
  
  // ã‚¤ãƒ™ãƒ³ãƒˆã®é©ç”¨ï¼ˆå†…éƒ¨çŠ¶æ…‹ã®æ›´æ–°ï¼‰
  private apply(event: Event, isNew: boolean = true): void {
    if (isNew) {
      this.pendingEvents.push(event);
    }
    
    switch (event.type) {
      case 'ORDER_CREATED':
        this.userId = event.data.userId;
        break;
      case 'ITEM_ADDED':
        this.items.push(event.data.item);
        this.recalculateTotal();
        break;
      case 'ITEM_REMOVED':
        this.items = this.items.filter(item => item.id !== event.data.itemId);
        this.recalculateTotal();
        break;
      case 'ORDER_CONFIRMED':
        this.status = OrderStatus.CONFIRMED;
        break;
      case 'ORDER_SHIPPED':
        this.status = OrderStatus.SHIPPED;
        break;
      // ä»–ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚¿ã‚¤ãƒ—...
    }
  }
  
  private recalculateTotal(): void {
    this.totalAmount = this.items.reduce(
      (total, item) => total + item.price * item.quantity, 
      0
    );
  }
  
  // ã‚³ãƒãƒ³ãƒ‰å‡¦ç†ï¼ˆçŠ¶æ…‹å¤‰æ›´ã®é–‹å§‹ç‚¹ï¼‰
  addItem(item: OrderItem): void {
    if (this.status !== OrderStatus.CREATED) {
      throw new Error('Cannot add items to a confirmed order');
    }
    
    const event: Event = {
      id: generateId(),
      type: 'ITEM_ADDED',
      aggregateId: this.id,
      data: { item },
      timestamp: new Date()
    };
    
    this.apply(event);
  }
  
  // ä»–ã®ã‚³ãƒãƒ³ãƒ‰ãƒ¡ã‚½ãƒƒãƒ‰...
  
  // æœªé©ç”¨ã‚¤ãƒ™ãƒ³ãƒˆã®å–å¾—ã¨ã‚³ãƒŸãƒƒãƒˆ
  async save(eventStore: EventStore): Promise<void> {
    if (this.pendingEvents.length === 0) {
      return;
    }
    
    await eventStore.saveEvents(this.id, this.pendingEvents);
    this.pendingEvents = [];
  }
}

// ã‚¯ã‚¨ãƒªå´ï¼ˆèª­ã¿å–ã‚Šæœ€é©åŒ–ãƒ¢ãƒ‡ãƒ«ï¼‰
class OrderReadModel {
  async getOrderDetails(orderId: string): Promise<OrderDetails> {
    // èª­ã¿å–ã‚Šå°‚ç”¨ãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆã‚¢ã‹ã‚‰ã®ç›´æ¥ã‚¯ã‚¨ãƒª
    return await this.orderRepository.findOrderDetailsById(orderId);
  }
  
  async getOrdersByUser(userId: string): Promise<OrderSummary[]> {
    // èª­ã¿å–ã‚Šå°‚ç”¨ãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆã‚¢ã‹ã‚‰ã®ç›´æ¥ã‚¯ã‚¨ãƒª
    return await this.orderRepository.findOrdersByUserId(userId);
  }
}
```

#### 3. å¤‰æ›´ãƒ‡ãƒ¼ã‚¿ã‚­ãƒ£ãƒ—ãƒãƒ£(CDC)

ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®å¤‰æ›´ã‚¤ãƒ™ãƒ³ãƒˆã‚’åˆ©ç”¨ã—ã¦ã€ã‚µãƒ¼ãƒ“ã‚¹é–“ã§ã®ãƒ‡ãƒ¼ã‚¿åŒæœŸã‚’å®Ÿç¾:

```typescript
// Debeziumãªã©ã®ãƒ„ãƒ¼ãƒ«ã«ã‚ˆã‚‹ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å¤‰æ›´ã‚¤ãƒ™ãƒ³ãƒˆã®å‡¦ç†
class UserProfileChangeHandler {
  // Kafkaãªã©ã‹ã‚‰å—ä¿¡ã—ãŸãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å¤‰æ›´ã‚¤ãƒ™ãƒ³ãƒˆã‚’å‡¦ç†
  async handleUserChange(changeEvent: any): Promise<void> {
    if (changeEvent.operation === 'UPDATE' || 
        changeEvent.operation === 'CREATE') {
      const userData = changeEvent.after;
      
      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«å¤‰æ›´ã«é–¢å¿ƒã®ã‚ã‚‹ä»–ã®ã‚µãƒ¼ãƒ“ã‚¹ã«é€šçŸ¥
      await this.publishToInterestedServices({
        eventType: 'USER_UPDATED',
        userId: userData.id,
        name: userData.name,
        email: userData.email,
        // ãã®ä»–ã®å…¬é–‹ã™ã¹ããƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
      });
    }
  }
  
  private async publishToInterestedServices(eventData: any): Promise<void> {
    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ–ãƒ­ãƒ¼ã‚«ãƒ¼ã‚’ä½¿ç”¨ã—ã¦ä»–ã®ã‚µãƒ¼ãƒ“ã‚¹ã«é€šçŸ¥
    await this.eventBus.publish('user-events', eventData);
  }
}
```

### åˆ†æ•£å‹ã‚¯ã‚¨ãƒªãƒ‘ã‚¿ãƒ¼ãƒ³

è¤‡æ•°ã‚µãƒ¼ãƒ“ã‚¹ã«ã¾ãŸãŒã‚‹ãƒ‡ãƒ¼ã‚¿å–å¾—æˆ¦ç•¥:

#### 1. APIã‚³ãƒ³ãƒã‚¸ã‚·ãƒ§ãƒ³

ã‚²ãƒ¼ãƒˆã‚¦ã‚§ã‚¤ãƒ¬ãƒ™ãƒ«ã§ã®ãƒ‡ãƒ¼ã‚¿é›†ç´„:

```typescript
// API Gatewayå†…ã§ã®ãƒ‡ãƒ¼ã‚¿é›†ç´„å®Ÿè£…
class ProductDetailsCompositionService {
  async getProductDetails(productId: string): Promise<ProductDetails> {
    // ä¸¦åˆ—ãƒªã‚¯ã‚¨ã‚¹ãƒˆã§å„ã‚µãƒ¼ãƒ“ã‚¹ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
    const [
      basicInfo,
      inventory,
      pricing,
      reviews
    ] = await Promise.all([
      this.productService.getProduct(productId),
      this.inventoryService.getInventoryStatus(productId),
      this.pricingService.getCurrentPricing(productId),
      this.reviewService.getProductReviews(productId, { limit: 5 })
    ]);
    
    // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®åˆæˆ
    return {
      id: productId,
      name: basicInfo.name,
      description: basicInfo.description,
      category: basicInfo.category,
      images: basicInfo.images,
      stockLevel: inventory.availableQuantity,
      inStock: inventory.availableQuantity > 0,
      price: pricing.currentPrice,
      discount: pricing.discountPercentage,
      reviewCount: reviews.totalCount,
      averageRating: reviews.averageRating,
      topReviews: reviews.items
    };
  }
}
```

#### 2. CQRSèª­ã¿å–ã‚Šãƒ¢ãƒ‡ãƒ«

ç‰¹å®šã®ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹å‘ã‘ã«æœ€é©åŒ–ã•ã‚ŒãŸèª­ã¿å–ã‚Šå°‚ç”¨ãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆã‚¢:

```typescript
// ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã«ã‚ˆã‚‹èª­ã¿å–ã‚Šãƒ¢ãƒ‡ãƒ«ã®æ›´æ–°
class ProductReadModelUpdater {
  async handleProductEvents(event: Event): Promise<void> {
    switch (event.type) {
      case 'PRODUCT_CREATED':
        await this.createProductReadModel(event.data);
        break;
      case 'PRODUCT_UPDATED':
        await this.updateProductReadModel(event.data);
        break;
      case 'INVENTORY_CHANGED':
        await this.updateProductInventory(event.data);
        break;
      case 'PRICE_CHANGED':
        await this.updateProductPrice(event.data);
        break;
      case 'REVIEW_ADDED':
        await this.updateProductReviews(event.data);
        break;
    }
  }
  
  private async updateProductReadModel(data: any): Promise<void> {
    // èª­ã¿å–ã‚Šãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã®è£½å“æƒ…å ±ã‚’æ›´æ–°
    await this.readModelRepository.updateProduct({
      id: data.productId,
      name: data.name,
      description: data.description,
      // ãã®ä»–ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
    });
  }
  
  // ä»–ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰...
}
```

## ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆã¨ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã®åŠ¹ç‡çš„ãªãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆã¨å®Ÿè¡Œç’°å¢ƒã®ç®¡ç†æ–¹æ³•ã«ã¤ã„ã¦è§£èª¬ã—ã¾ã™ã€‚

### ã‚³ãƒ³ãƒ†ãƒŠåŒ–ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

åŠ¹ç‡çš„ãªDockerfileã®ä¾‹:

```dockerfile
# ãƒ“ãƒ«ãƒ‰ã‚¹ãƒ†ãƒ¼ã‚¸
FROM node:18-alpine AS build

WORKDIR /app

# ä¾å­˜é–¢ä¿‚ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã™ã‚‹ãŸã‚ã«å…ˆã«ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
COPY package*.json ./
RUN npm ci

# ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã®ã‚³ãƒ”ãƒ¼ã¨ãƒ“ãƒ«ãƒ‰
COPY tsconfig.json ./
COPY src/ ./src/
RUN npm run build

# å®Ÿè¡Œã‚¹ãƒ†ãƒ¼ã‚¸
FROM node:18-alpine AS runtime

# érootãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ä½œæˆ
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001 -G nodejs

WORKDIR /app

# æœ¬ç•ªä¾å­˜é–¢ä¿‚ã®ã¿ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
COPY package*.json ./
RUN npm ci --only=production && \
    npm cache clean --force

# ãƒ“ãƒ«ãƒ‰ã‚¹ãƒ†ãƒ¼ã‚¸ã‹ã‚‰ã®æˆæœç‰©ã‚’ã‚³ãƒ”ãƒ¼
COPY --from=build /app/dist ./dist

# érootãƒ¦ãƒ¼ã‚¶ãƒ¼ã«åˆ‡ã‚Šæ›¿ãˆ
USER nodejs

# ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã®è¨­å®š
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:3000/health || exit 1

# ç’°å¢ƒå¤‰æ•°ã®è¨­å®š
ENV NODE_ENV=production \
    PORT=3000

# ãƒãƒ¼ãƒˆã®å…¬é–‹
EXPOSE 3000

# ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®èµ·å‹•
CMD ["node", "dist/index.js"]
```

### Kubernetesãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆ

ä¸€èˆ¬çš„ãªãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã®Kubernetesãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆä¾‹:

```yaml
# order-service.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: order-service
  labels:
    app: order-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: order-service
  strategy:
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  template:
    metadata:
      labels:
        app: order-service
    spec:
      containers:
      - name: order-service
        image: my-registry/order-service:v1.2.3
        ports:
        - containerPort: 3000
        resources:
          requests:
            cpu: 100m
            memory: 256Mi
          limits:
            cpu: 500m
            memory: 512Mi
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: order-service-secrets
              key: database-url
        - name: KAFKA_BOOTSTRAP_SERVERS
          valueFrom:
            configMapKeyRef:
              name: kafka-config
              key: bootstrap-servers
        readinessProbe:
          httpGet:
            path: /health/readiness
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 10
        livenessProbe:
          httpGet:
            path: /health/liveness
            port: 3000
          initialDelaySeconds: 15
          periodSeconds: 20
      securityContext:
        runAsUser: 1001
        runAsGroup: 1001
        fsGroup: 1001
---
apiVersion: v1
kind: Service
metadata:
  name: order-service
spec:
  selector:
    app: order-service
  ports:
  - port: 80
    targetPort: 3000
  type: ClusterIP
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: order-service-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
  - host: api.example.com
    http:
      paths:
      - path: /orders
        pathType: Prefix
        backend:
          service:
            name: order-service
            port:
              number: 80
```

### CI/CDãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³

GitHub Actionsã«ã‚ˆã‚‹CI/CDãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ä¾‹:

```yaml
# .github/workflows/order-service-pipeline.yml
name: Order Service Pipeline

on:
  push:
    branches: [ main ]
    paths:
      - 'services/order-service/**'
      - '.github/workflows/order-service-pipeline.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'services/order-service/**'

jobs:
  test:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: services/order-service
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: services/order-service/package-lock.json
      
      - name: Install dependencies
        run: npm ci
      
      - name: Lint
        run: npm run lint
      
      - name: Run unit tests
        run: npm test
      
      - name: Run integration tests
        run: npm run test:integration
  
  build-and-deploy:
    needs: test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      - name: Login to Container Registry
        uses: docker/login-action@v2
        with:
          registry: my-registry.example.com
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}
      
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: my-registry.example.com/order-service
          tags: |
            type=sha,format=long
            type=raw,value=latest
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: services/order-service
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=registry,ref=my-registry.example.com/order-service:latest
          cache-to: type=inline
      
      - name: Deploy to Kubernetes
        uses: azure/k8s-deploy@v1
        with:
          namespace: production
          manifests: |
            services/order-service/k8s/deployment.yaml
          images: |
            my-registry.example.com/order-service:${{ steps.meta.outputs.version }}
          imagepullsecrets: |
            registry-credentials
```

### è¨­å®šç®¡ç†

Kubernetesã‚’ä½¿ç”¨ã—ãŸè¨­å®šç®¡ç†ã®ä¾‹:

```yaml
# config-maps.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: order-service-config
data:
  ORDER_SERVICE_PORT: "3000"
  KAFKA_TOPIC_ORDER_EVENTS: "order-events"
  METRICS_ENABLED: "true"
  LOG_LEVEL: "info"
---
# secrets.yaml
apiVersion: v1
kind: Secret
metadata:
  name: order-service-secrets
type: Opaque
data:
  database-url: cG9zdGdyZXNxbDovL3VzZXJuYW1lOnBhc3N3b3JkQGhvc3Q6NTQzMi9kYXRhYmFzZQ==
  api-key: c2VjcmV0LWFwaS1rZXk=
```

## ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã¨å¯è¦³æ¸¬æ€§

ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã®ç›£è¦–ã¨å•é¡Œè§£æ±ºã®ãŸã‚ã®å®Ÿè·µçš„ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’ç´¹ä»‹ã—ã¾ã™ã€‚

### åˆ†æ•£ãƒˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°

OpenTelemetryã‚’ä½¿ç”¨ã—ãŸåˆ†æ•£ãƒˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°ã®å®Ÿè£…ä¾‹:

```typescript
// ãƒˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°è¨­å®šã¨ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ï¼ˆExpress.jsï¼‰
import * as opentelemetry from '@opentelemetry/sdk-node';
import { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';
import { Resource } from '@opentelemetry/resources';
import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions';
import { ExpressInstrumentation } from '@opentelemetry/instrumentation-express';
import { HttpInstrumentation } from '@opentelemetry/instrumentation-http';

// OpenTelemetry SDKåˆæœŸåŒ–
const initTelemetry = () => {
  const traceExporter = new OTLPTraceExporter({
    url: 'http://jaeger-collector:4318/v1/traces',
  });

  const sdk = new opentelemetry.NodeSDK({
    resource: new Resource({
      [SemanticResourceAttributes.SERVICE_NAME]: 'order-service',
      [SemanticResourceAttributes.SERVICE_VERSION]: '1.0.0',
      [SemanticResourceAttributes.DEPLOYMENT_ENVIRONMENT]: 'production',
    }),
    traceExporter,
    instrumentations: [
      getNodeAutoInstrumentations({
        '@opentelemetry/instrumentation-express': {
          enabled: true,
        },
        '@opentelemetry/instrumentation-http': {
          enabled: true,
        },
      }),
    ],
  });

  sdk.start();
  
  // ãƒ—ãƒ­ã‚»ã‚¹çµ‚äº†æ™‚ã«ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
  process.on('SIGTERM', () => {
    sdk.shutdown()
      .then(() => console.log('Tracing terminated'))
      .catch((error) => console.error('Error terminating tracing', error))
      .finally(() => process.exit(0));
  });
};

// ãƒˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°ã®åˆæœŸåŒ–
initTelemetry();

// ã‚«ã‚¹ã‚¿ãƒ ã‚¹ãƒ‘ãƒ³ã®ä½œæˆï¼ˆãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯å†…ï¼‰
import { trace, context } from '@opentelemetry/api';

async function processOrder(orderData) {
  // ç¾åœ¨ã®ãƒˆãƒ¬ãƒ¼ã‚µãƒ¼ã¨ã‚¹ãƒ‘ãƒ³ã‚’å–å¾—
  const tracer = trace.getTracer('order-service');
  
  // æ–°ã—ã„ã‚¹ãƒ‘ãƒ³ã‚’ä½œæˆ
  const span = tracer.startSpan('process-order');
  
  // ã‚¹ãƒ‘ãƒ³ã«å±æ€§ã‚’è¿½åŠ 
  span.setAttribute('order.id', orderData.id);
  span.setAttribute('order.items.count', orderData.items.length);
  span.setAttribute('order.total', orderData.totalAmount);
  
  // ç¾åœ¨ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¨ã‚¹ãƒ‘ãƒ³ã‚’é–¢é€£ä»˜ã‘
  return context.with(trace.setSpan(context.active(), span), async () => {
    try {
      // æ³¨æ–‡æ¤œè¨¼ã‚¹ãƒ‘ãƒ³
      await tracer.startActiveSpan('validate-order', async (validateSpan) => {
        try {
          await validateOrder(orderData);
          validateSpan.end();
        } catch (error) {
          validateSpan.recordException(error);
          validateSpan.setStatus({ code: SpanStatusCode.ERROR });
          validateSpan.end();
          throw error;
        }
      });
      
      // åœ¨åº«ç¢ºèªã‚¹ãƒ‘ãƒ³
      await tracer.startActiveSpan('check-inventory', async (inventorySpan) => {
        try {
          await checkInventory(orderData.items);
          inventorySpan.end();
        } catch (error) {
          inventorySpan.recordException(error);
          inventorySpan.setStatus({ code: SpanStatusCode.ERROR });
          inventorySpan.end();
          throw error;
        }
      });
      
      // æ”¯æ‰•ã„å‡¦ç†ã‚¹ãƒ‘ãƒ³
      await tracer.startActiveSpan('process-payment', async (paymentSpan) => {
        try {
          await processPayment(orderData);
          paymentSpan.end();
        } catch (error) {
          paymentSpan.recordException(error);
          paymentSpan.setStatus({ code: SpanStatusCode.ERROR });
          paymentSpan.end();
          throw error;
        }
      });
      
      return { success: true, orderId: orderData.id };
    } catch (error) {
      // ã‚¨ãƒ©ãƒ¼æƒ…å ±ã‚’ã‚¹ãƒ‘ãƒ³ã«è¨˜éŒ²
      span.recordException(error);
      span.setStatus({ code: SpanStatusCode.ERROR });
      throw error;
    } finally {
      // ã‚¹ãƒ‘ãƒ³ã®çµ‚äº†
      span.end();
    }
  });
}
```

### ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†

Prometheusã‚’ä½¿ç”¨ã—ãŸãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†ã¨ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ä½œæˆ:

```typescript
// Prometheusãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’Expressã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«çµ±åˆ
import express from 'express';
import client from 'prom-client';

const app = express();
const register = new client.Registry();

// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®è¿½åŠ ï¼ˆGC, ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãªã©ï¼‰
client.collectDefaultMetrics({ register });

// ã‚«ã‚¹ã‚¿ãƒ ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®ä½œæˆ
const httpRequestsTotal = new client.Counter({
  name: 'http_requests_total',
  help: 'Total number of HTTP requests',
  labelNames: ['method', 'path', 'status'],
  registers: [register],
});

// ã‚«ã‚¹ã‚¿ãƒ ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®ä½œæˆ
const httpRequestDurationMs = new client.Histogram({
  name: 'http_request_duration_ms',
  help: 'HTTP request duration in milliseconds',
  labelNames: ['method', 'path', 'status'],
  buckets: [10, 50, 100, 200, 500, 1000, 2000, 5000],
  registers: [register],
});

// ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
app.use((req, res, next) => {
  const start = Date.now();
  
  // ãƒ¬ã‚¹ãƒãƒ³ã‚¹å®Œäº†æ™‚ã«ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’è¨˜éŒ²
  res.on('finish', () => {
    const duration = Date.now() - start;
    const { method, path } = req;
    const { statusCode } = res;
    
    httpRequestsTotal.inc({ method, path, status: statusCode });
    httpRequestDurationMs.observe({ method, path, status: statusCode }, duration);
  });
  
  next();
});

// ãƒ“ã‚¸ãƒã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®ä½œæˆ
const activeOrders = new client.Gauge({
  name: 'orders_active_total',
  help: 'Total number of active orders',
  registers: [register],
});

const orderProcessingDurationMs = new client.Histogram({
  name: 'order_processing_duration_ms',
  help: 'Order processing duration in milliseconds',
  buckets: [100, 500, 1000, 5000, 10000, 30000, 60000],
  registers: [register],
});

// ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯å†…ã§ã®ãƒ¡ãƒˆãƒªã‚¯ã‚¹ä½¿ç”¨ä¾‹
async function processOrder(orderData) {
  const start = Date.now();
  activeOrders.inc();
  
  try {
    // æ³¨æ–‡å‡¦ç†ãƒ­ã‚¸ãƒƒã‚¯...
    return result;
  } finally {
    activeOrders.dec();
    const duration = Date.now() - start;
    orderProcessingDurationMs.observe(duration);
  }
}

// Prometheusãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®å…¬é–‹
app.get('/metrics', async (req, res) => {
  res.set('Content-Type', register.contentType);
  res.end(await register.metrics());
});
```

### ãƒ­ã‚°ç®¡ç†

åŠ¹æœçš„ãªãƒ­ã‚®ãƒ³ã‚°æˆ¦ç•¥:

```typescript
// æ§‹é€ åŒ–ãƒ­ã‚®ãƒ³ã‚°ã®å®Ÿè£…ï¼ˆWinston + ELKï¼‰
import winston from 'winston';

// ã‚«ã‚¹ã‚¿ãƒ ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«ã®å®šç¾©
const levels = {
  error: 0,
  warn: 1,
  info: 2,
  http: 3,
  debug: 4,
};

// ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«ã®æ±ºå®šï¼ˆç’°å¢ƒã«åŸºã¥ãï¼‰
const level = () => {
  const env = process.env.NODE_ENV || 'development';
  return env === 'development' ? 'debug' : 'info';
};

// ãƒ­ã‚°ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®å®šç¾©
const format = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss:ms' }),
  winston.format.printf((info) => {
    const {
      timestamp, level, message, service, ...meta
    } = info;
    
    // ãƒˆãƒ¬ãƒ¼ã‚¹IDã‚’å«ã‚€ï¼ˆOpenTelemetryã¨çµ±åˆï¼‰
    const traceId = meta.traceId || 'unknown';
    const spanId = meta.spanId || 'unknown';
    
    // æ§‹é€ åŒ–ãƒ­ã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
    return JSON.stringify({
      timestamp,
      level,
      message,
      service: 'order-service',
      traceId,
      spanId,
      ...meta,
    });
  })
);

// ãƒ­ã‚¬ãƒ¼ã®åˆæœŸåŒ–
const logger = winston.createLogger({
  level: level(),
  levels,
  format,
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' }),
  ],
});

// ãƒ­ã‚°ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®è‡ªå‹•å–å¾—
import { context, trace } from '@opentelemetry/api';

function getTraceInfo() {
  const activeSpan = trace.getSpan(context.active());
  if (!activeSpan) return {};
  
  const { spanId, traceId } = activeSpan.spanContext();
  return { traceId, spanId };
}

// å®Ÿéš›ã®ãƒ­ã‚°å‡ºåŠ›ä¾‹
function processOrder(order) {
  const traceInfo = getTraceInfo();
  
  logger.info('Started processing order', { 
    orderId: order.id,
    customerId: order.customerId,
    amount: order.totalAmount,
    ...traceInfo 
  });
  
  try {
    // ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯
    validateOrder(order);
    
    logger.debug('Order validation successful', { 
      orderId: order.id,
      ...traceInfo 
    });
    
    // å‡¦ç†ç¶šè¡Œ...
    
    logger.info('Order processing completed', { 
      orderId: order.id, 
      status: 'COMPLETED',
      processingTimeMs: 1200, // å®Ÿéš›ã®å‡¦ç†æ™‚é–“ã‚’è¨ˆæ¸¬
      ...traceInfo 
    });
  } catch (error) {
    logger.error('Failed to process order', {
      orderId: order.id,
      errorCode: error.code,
      errorMessage: error.message,
      stackTrace: error.stack,
      ...traceInfo
    });
    throw error;
  }
}
```

### ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã¨éšœå®³æ¤œå‡º

ä¿¡é ¼æ€§ã®é«˜ã„ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯å®Ÿè£…:

```typescript
// Express.jsã§ã®ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå®Ÿè£…
import express from 'express';
import { Pool } from 'pg';
import { Kafka } from 'kafkajs';

const app = express();

// ä¾å­˜ã‚µãƒ¼ãƒ“ã‚¹ã¸ã®æ¥ç¶š
const dbPool = new Pool({
  connectionString: process.env.DATABASE_URL
});

const kafka = new Kafka({
  clientId: 'order-service',
  brokers: process.env.KAFKA_BROKERS.split(',')
});

const producer = kafka.producer();

// èµ·å‹•æ™‚ã«æ¥ç¶šã®åˆæœŸåŒ–
async function initializeConnections() {
  try {
    await producer.connect();
    console.log('Successfully connected to Kafka');
  } catch (error) {
    console.error('Failed to connect to Kafka:', error);
  }
}

initializeConnections();

// ç°¡æ˜“ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ï¼ˆå˜ç´”ãªç¨¼åƒç¢ºèªï¼‰
app.get('/health', (req, res) => {
  res.status(200).json({ status: 'UP' });
});

// è©³ç´°ãªãƒ¬ãƒ‡ã‚£ãƒã‚¹ãƒ—ãƒ­ãƒ¼ãƒ–ï¼ˆä¾å­˜é–¢ä¿‚ã®çŠ¶æ…‹ç¢ºèªï¼‰
app.get('/health/readiness', async (req, res) => {
  const health = {
    status: 'UP',
    components: {
      database: { status: 'UNKNOWN' },
      kafka: { status: 'UNKNOWN' },
    },
    timestamp: new Date().toISOString()
  };
  
  // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šãƒã‚§ãƒƒã‚¯
  try {
    const client = await dbPool.connect();
    try {
      await client.query('SELECT 1');
      health.components.database = { status: 'UP' };
    } finally {
      client.release();
    }
  } catch (error) {
    health.components.database = {
      status: 'DOWN',
      details: error.message
    };
    health.status = 'DOWN';
  }
  
  // Kafkaæ¥ç¶šãƒã‚§ãƒƒã‚¯
  try {
    const isConnected = producer.isConnected();
    health.components.kafka = {
      status: isConnected ? 'UP' : 'DOWN'
    };
    
    if (!isConnected) {
      health.status = 'DOWN';
    }
  } catch (error) {
    health.components.kafka = {
      status: 'DOWN',
      details: error.message
    };
    health.status = 'DOWN';
  }
  
  // é©åˆ‡ãªHTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’è¿”ã™
  const statusCode = health.status === 'UP' ? 200 : 503;
  res.status(statusCode).json(health);
});

// ãƒ©ã‚¤ãƒ–ãƒã‚¹ãƒ—ãƒ­ãƒ¼ãƒ–ï¼ˆã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å†…éƒ¨çŠ¶æ…‹ã®ç¢ºèªï¼‰
app.get('/health/liveness', (req, res) => {
  const health = {
    status: 'UP',
    uptime: process.uptime(),
    memoryUsage: process.memoryUsage(),
    timestamp: new Date().toISOString()
  };
  
  // ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯æ¤œå‡ºã®ç°¡æ˜“ãƒã‚§ãƒƒã‚¯
  const memoryThresholdMB = 1024; // 1GB
  const memoryUsedMB = Math.round(health.memoryUsage.rss / 1024 / 1024);
  
  if (memoryUsedMB > memoryThresholdMB) {
    health.status = 'DOWN';
    health.details = `Memory usage exceeded threshold: ${memoryUsedMB}MB > ${memoryThresholdMB}MB`;
  }
  
  const statusCode = health.status === 'UP' ? 200 : 503;
  res.status(statusCode).json(health);
});
```

## éšœå®³å¯¾å¿œã¨å›å¾©åŠ›

ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã®éšœå®³å¯¾å¿œã¨å›å¾©åŠ›ã‚’é«˜ã‚ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç´¹ä»‹ã—ã¾ã™ã€‚

### ã‚µãƒ¼ã‚­ãƒƒãƒˆãƒ–ãƒ¬ãƒ¼ã‚«ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³

å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹å‘¼ã³å‡ºã—ã®éšœå®³ã‚’åˆ¶å¾¡ã™ã‚‹ã‚µãƒ¼ã‚­ãƒƒãƒˆãƒ–ãƒ¬ãƒ¼ã‚«ãƒ¼ã®å®Ÿè£…:

```typescript
// Oposumãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã‚ˆã‚‹ã‚µãƒ¼ã‚­ãƒƒãƒˆãƒ–ãƒ¬ãƒ¼ã‚«ãƒ¼ã®å®Ÿè£…
import CircuitBreaker from 'opossum';

class PaymentService {
  private paymentGatewayClient: PaymentGatewayClient;
  private circuitBreaker: CircuitBreaker;
  
  constructor() {
    this.paymentGatewayClient = new PaymentGatewayClient();
    
    // ã‚µãƒ¼ã‚­ãƒƒãƒˆãƒ–ãƒ¬ãƒ¼ã‚«ãƒ¼ã®è¨­å®š
    this.circuitBreaker = new CircuitBreaker(
      async (paymentRequest: PaymentRequest) => {
        return await this.paymentGatewayClient.processPayment(paymentRequest);
      },
      {
        // 5å›ã®é€£ç¶šå¤±æ•—ã§ã‚µãƒ¼ã‚­ãƒƒãƒˆã‚’ã‚ªãƒ¼ãƒ—ãƒ³
        failureThreshold: 5,
        // ã‚ªãƒ¼ãƒ—ãƒ³çŠ¶æ…‹ã®ç¶™ç¶šæ™‚é–“ (ms)
        resetTimeout: 30000,
        // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®š (ms)
        timeout: 5000,
        // ã‚¨ãƒ©ãƒ¼ã¨ã—ã¦æ‰±ã†æ¡ä»¶
        errorThresholdPercentage: 50,
        // åŠã‚ªãƒ¼ãƒ—ãƒ³çŠ¶æ…‹ã§ã®è©¦è¡Œå›æ•°
        rollingCountTimeout: 10,
        // çµ±è¨ˆæƒ…å ±å–å¾—ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ (ms)
        rollingCountBuckets: 10,
        // å¤±æ•—ã¨ã¿ãªã™ä¾‹å¤–ã¨æ¡ä»¶
        isErrorHandler: (error) => {
          // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ã‚„500ç³»ã‚¨ãƒ©ãƒ¼ã®ã¿å¤±æ•—ã¨ã—ã¦ã‚«ã‚¦ãƒ³ãƒˆ
          return (
            error.name === 'NetworkError' ||
            (error.status && error.status >= 500)
          );
        }
      }
    );
    
    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¿½åŠ 
    this.circuitBreaker.on('open', () => {
      console.log('Circuit breaker opened');
    });
    
    this.circuitBreaker.on('halfOpen', () => {
      console.log('Circuit breaker half-open');
    });
    
    this.circuitBreaker.on('close', () => {
      console.log('Circuit breaker closed');
    });
    
    this.circuitBreaker.on('fallback', (result, err) => {
      console.log('Circuit breaker fallback executed', err);
    });
  }
  
  async processPayment(paymentRequest: PaymentRequest): Promise<PaymentResult> {
    try {
      // ã‚µãƒ¼ã‚­ãƒƒãƒˆãƒ–ãƒ¬ãƒ¼ã‚«ãƒ¼çµŒç”±ã§æ”¯æ‰•ã„å‡¦ç†ã‚’å®Ÿè¡Œ
      return await this.circuitBreaker.fire(paymentRequest);
    } catch (error) {
      // ã‚µãƒ¼ã‚­ãƒƒãƒˆãŒã‚ªãƒ¼ãƒ—ãƒ³çŠ¶æ…‹ã‹ã€å‘¼ã³å‡ºã—ãŒå¤±æ•—ã—ãŸå ´åˆ
      if (this.circuitBreaker.opened) {
        console.log('Payment service unavailable, using fallback response');
        return this.fallbackPaymentProcess(paymentRequest);
      }
      throw error;
    }
  }
  
  private async fallbackPaymentProcess(
    paymentRequest: PaymentRequest
  ): Promise<PaymentResult> {
    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³:
    // 1. ã‚­ãƒ¥ãƒ¼ã«å…¥ã‚Œã¦å¾Œã§å‡¦ç†
    await this.paymentQueue.enqueue(paymentRequest);
    
    // 2. ä»£æ›¿æ”¯æ‰•ã„ã‚²ãƒ¼ãƒˆã‚¦ã‚§ã‚¤ã‚’ä½¿ç”¨
    // return await this.backupPaymentGateway.processPayment(paymentRequest);
    
    // 3. ç„¡åŠ¹ãªæ”¯æ‰•ã„ã¨ã—ã¦ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™
    throw new Error('Payment service unavailable, please try again later');
  }
}
```

### ãƒªãƒˆãƒ©ã‚¤ãƒ‘ã‚¿ãƒ¼ãƒ³

ä¸€æ™‚çš„ãªéšœå®³ã«å¯¾å‡¦ã™ã‚‹ãƒªãƒˆãƒ©ã‚¤ãƒ­ã‚¸ãƒƒã‚¯ã®å®Ÿè£…:

```typescript
// æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•ä»˜ããƒªãƒˆãƒ©ã‚¤ã®å®Ÿè£…
async function retryWithExponentialBackoff<T>(
  operation: () => Promise<T>,
  options: {
    maxRetries?: number;
    initialDelayMs?: number;
    maxDelayMs?: number;
    backoffFactor?: number;
    retryableErrors?: Array<string | RegExp>;
  } = {}
): Promise<T> {
  const {
    maxRetries = 5,
    initialDelayMs = 100,
    maxDelayMs = 10000,
    backoffFactor = 2,
    retryableErrors = []
  } = options;
  
  let attempt = 0;
  let delay = initialDelayMs;
  
  const isRetryableError = (error: any): boolean => {
    // ç‰¹å®šã®ä¾‹å¤–ã‚¯ãƒ©ã‚¹ã‚„ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§ãƒªãƒˆãƒ©ã‚¤ã‚’åˆ¤æ–­
    if (retryableErrors.length === 0) {
      // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ã‚„ä¸€æ™‚çš„ãªéšœå®³ã®ã¿ãƒªãƒˆãƒ©ã‚¤
      return (
        error.name === 'NetworkError' ||
        error.name === 'TimeoutError' ||
        error.message?.includes('timeout') ||
        error.message?.includes('socket hang up') ||
        (error.status && 
          (error.status === 429 || 
           error.status >= 500 && error.status < 600))
      );
    }
    
    // æŒ‡å®šã•ã‚ŒãŸã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—ã«ä¸€è‡´ã™ã‚‹ã‹
    return retryableErrors.some(pattern => {
      if (typeof pattern === 'string') {
        return error.name === pattern || error.message?.includes(pattern);
      }
      return pattern.test(error.message || '');
    });
  };
  
  while (true) {
    try {
      return await operation();
    } catch (error) {
      attempt++;
      
      if (attempt >= maxRetries || !isRetryableError(error)) {
        throw error;
      }
      
      // æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•ã®è¨ˆç®—ï¼ˆãƒ©ãƒ³ãƒ€ãƒ åŒ–ï¼‰
      const jitter = Math.random() * 0.3 + 0.8; // 0.8ã€œ1.1ã®ä¹±æ•°
      delay = Math.min(delay * backoffFactor * jitter, maxDelayMs);
      
      console.log(
        `Retry attempt ${attempt}/${maxRetries} for operation after ${Math.round(delay)}ms`
      );
      
      // å¾…æ©Ÿ
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

// ä½¿ç”¨ä¾‹
async function fetchInventory(productId: string): Promise<InventoryStatus> {
  return retryWithExponentialBackoff(
    async () => {
      const response = await fetch(`/inventory/${productId}`);
      if (!response.ok) {
        const error: any = new Error('Failed to fetch inventory');
        error.status = response.status;
        throw error;
      }
      return await response.json();
    },
    {
      maxRetries: 3,
      initialDelayMs: 200,
      retryableErrors: ['NetworkError', 'TimeoutError', /^5\d\d$/]
    }
  );
}
```

### ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã¨ãƒãƒ«ã‚¯ãƒ˜ãƒƒãƒ‰

ã‚µãƒ¼ãƒ“ã‚¹ã®å®‰å®šæ€§ã‚’ç¢ºä¿ã™ã‚‹ãƒªã‚½ãƒ¼ã‚¹åˆ¶å¾¡ãƒ‘ã‚¿ãƒ¼ãƒ³:

```typescript
// Express.jsãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã«ã‚ˆã‚‹ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã®å®Ÿè£…
import rateLimit from 'express-rate-limit';
import RedisStore from 'rate-limit-redis';
import Redis from 'ioredis';

const redisClient = new Redis({
  host: process.env.REDIS_HOST,
  port: parseInt(process.env.REDIS_PORT || '6379'),
});

// APIãƒ¬ãƒ¼ãƒˆåˆ¶é™ã®è¨­å®š
const apiLimiter = rateLimit({
  store: new RedisStore({
    client: redisClient,
    prefix: 'rate-limit:',
    // RedisStoreã®è¨­å®š
  }),
  windowMs: 15 * 60 * 1000, // 15åˆ†ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦
  max: 100, // IPã‚¢ãƒ‰ãƒ¬ã‚¹ã”ã¨ã«15åˆ†ã‚ãŸã‚Š100ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
  standardHeaders: true, // X-RateLimit-* ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’å«ã‚ã‚‹
  legacyHeaders: false, // X-Rate-Limit-* ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’å«ã‚ãªã„
  message: {
    status: 429,
    message: 'Too many requests, please try again later.',
  },
});

// èªè¨¼æ¸ˆã¿ãƒ¦ãƒ¼ã‚¶ãƒ¼å‘ã‘åˆ¶é™
const authenticatedLimiter = rateLimit({
  store: new RedisStore({
    client: redisClient,
    prefix: 'rate-limit-auth:',
  }),
  windowMs: 15 * 60 * 1000,
  max: 500, // èªè¨¼æ¸ˆã¿ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã¯é«˜ã„åˆ¶é™å€¤ã‚’è¨­å®š
  standardHeaders: true,
  legacyHeaders: false,
  // ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã§ã‚­ãƒ¼ã‚’ç”Ÿæˆ
  keyGenerator: (req) => {
    return req.user?.id || req.ip;
  },
});

// ç‰¹å®šã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®åˆ¶é™
const orderCreationLimiter = rateLimit({
  store: new RedisStore({
    client: redisClient,
    prefix: 'rate-limit-orders:',
  }),
  windowMs: 60 * 60 * 1000, // 1æ™‚é–“ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦
  max: 10, // 1æ™‚é–“ã«10æ³¨æ–‡ã¾ã§
  message: {
    status: 429,
    message: 'Order creation rate limit exceeded.',
  },
});

// ãƒãƒ«ã‚¯ãƒ˜ãƒƒãƒ‰ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆã‚µãƒ¼ãƒ“ã‚¹åˆ†é›¢ï¼‰ã®å®Ÿè£…
import { Semaphore } from 'async-mutex';

// ä¸¦è¡Œãƒªã‚¯ã‚¨ã‚¹ãƒˆæ•°ã‚’åˆ¶é™ã™ã‚‹ã‚»ãƒãƒ•ã‚©
const paymentServiceSemaphore = new Semaphore(10); // æœ€å¤§10ã®ä¸¦è¡Œå‡¦ç†
const inventoryServiceSemaphore = new Semaphore(20); // æœ€å¤§20ã®ä¸¦è¡Œå‡¦ç†

// ãƒãƒ«ã‚¯ãƒ˜ãƒƒãƒ‰ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’é©ç”¨ã—ãŸæ”¯æ‰•ã„å‡¦ç†
async function processPayment(paymentRequest: PaymentRequest): Promise<PaymentResult> {
  // ã‚»ãƒãƒ•ã‚©ã®å–å¾—ã‚’è©¦ã¿ã‚‹
  const release = await paymentServiceSemaphore.acquire();
  
  try {
    // åˆ¶é™ã•ã‚ŒãŸä¸¦è¡Œå‡¦ç†å†…ã§å®Ÿè¡Œ
    return await paymentService.processPayment(paymentRequest);
  } finally {
    // ã‚»ãƒãƒ•ã‚©ã®ãƒªãƒªãƒ¼ã‚¹ï¼ˆå¿…ãšå®Ÿè¡Œï¼‰
    release();
  }
}

// APIãƒ«ãƒ¼ã‚¿ãƒ¼ã¸ã®é©ç”¨
const app = express();

// å…¨èˆ¬çš„ãªãƒ¬ãƒ¼ãƒˆåˆ¶é™
app.use('/api/', apiLimiter);

// èªè¨¼ãŒå¿…è¦ãªã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
app.use('/api/accounts', authenticatedLimiter);

// ç‰¹å®šæ“ä½œã®åˆ¶é™
app.post('/api/orders', orderCreationLimiter, createOrderHandler);
```

## ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã®é€²åŒ–ã¨ä¿å®ˆ

ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã‚’é•·æœŸçš„ã«ç¶­æŒãƒ»ç™ºå±•ã•ã›ã‚‹ãŸã‚ã®æˆ¦ç•¥ã‚’ç´¹ä»‹ã—ã¾ã™ã€‚

### ãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°æˆ¦ç•¥

APIã®ä¸‹ä½äº’æ›æ€§ã‚’ç¶­æŒã™ã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°:

```typescript
// Express.jsã‚’ä½¿ç”¨ã—ãŸAPIãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°
import express from 'express';
import semver from 'semver';

const app = express();

// ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒ˜ãƒƒãƒ€ãƒ¼ã®ãƒ‘ãƒ¼ã‚¹
function parseAcceptVersion(versionHeader: string): string | null {
  // 'application/json;version=1.2.3'å½¢å¼ã®ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ãƒ‘ãƒ¼ã‚¹
  const match = versionHeader.match(/version=([0-9.]+)/);
  return match ? match[1] : null;
}

// ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
function versionMiddleware(req: express.Request, res: express.Response, next: express.NextFunction) {
  const acceptHeader = req.get('Accept') || '';
  const version = parseAcceptVersion(acceptHeader) || '1.0.0';
  
  req.apiVersion = version;
  next();
}

app.use(versionMiddleware);

// ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«åŸºã¥ã„ãŸãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°
function versionRoute(versions: {
  [version: string]: express.RequestHandler;
}): express.RequestHandler {
  return (req, res, next) => {
    const clientVersion = req.apiVersion || '1.0.0';
    
    // ã‚µãƒãƒ¼ãƒˆå¯¾è±¡ã®æœ€å¤§ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’è¦‹ã¤ã‘ã‚‹
    const supportedVersions = Object.keys(versions);
    const matchingVersion = supportedVersions
      .filter(v => semver.lte(v, clientVersion))
      .sort(semver.rcompare)[0];
    
    if (matchingVersion) {
      return versions[matchingVersion](req, res, next);
    }
    
    // ä¸€è‡´ã™ã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒãªã„å ´åˆã¯æœ€ã‚‚å¤ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ä½¿ç”¨
    const oldestVersion = supportedVersions.sort(semver.compare)[0];
    return versions[oldestVersion](req, res, next);
  };
}

// ãƒãƒ¼ã‚¸ãƒ§ãƒ³åˆ¥ã®å®Ÿè£…
app.get('/api/orders/:id', versionRoute({
  // v1: åŸºæœ¬çš„ãªæ³¨æ–‡æƒ…å ±
  '1.0.0': (req, res) => {
    const order = orderService.getOrder(req.params.id);
    res.json({
      id: order.id,
      status: order.status,
      items: order.items,
      totalAmount: order.totalAmount
    });
  },
  // v2: é…é€æƒ…å ±ã‚’è¿½åŠ 
  '2.0.0': (req, res) => {
    const order = orderService.getOrder(req.params.id);
    res.json({
      id: order.id,
      status: order.status,
      items: order.items,
      totalAmount: order.totalAmount,
      shipping: {
        status: order.shippingStatus,
        trackingNumber: order.trackingNumber,
        estimatedDelivery: order.estimatedDelivery
      }
    });
  },
  // v3: æ”¯æ‰•ã„æƒ…å ±ã¨å±¥æ­´ã‚’è¿½åŠ 
  '3.0.0': async (req, res) => {
    const order = await orderService.getOrderWithDetails(req.params.id);
    res.json({
      id: order.id,
      status: order.status,
      items: order.items,
      totalAmount: order.totalAmount,
      shipping: {
        status: order.shippingStatus,
        trackingNumber: order.trackingNumber,
        estimatedDelivery: order.estimatedDelivery
      },
      payment: {
        method: order.paymentMethod,
        status: order.paymentStatus,
        lastUpdated: order.paymentLastUpdated
      },
      history: order.statusHistory
    });
  }
}));
```

### æ®µéšçš„ãªãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ç§»è¡Œ

ãƒ¢ãƒãƒªã‚¹ã‹ã‚‰ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã¸ã®æ®µéšçš„ãªç§»è¡Œæˆ¦ç•¥:

```typescript
// ã‚¹ãƒˆãƒ©ãƒ³ã‚°ãƒ©ãƒ¼ãƒ•ã‚£ã‚°ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å®Ÿè£…ï¼ˆAPIã‚²ãƒ¼ãƒˆã‚¦ã‚§ã‚¤ï¼‰
import express from 'express';
import { createProxyMiddleware } from 'http-proxy-middleware';

const app = express();

// æ©Ÿèƒ½ãƒ•ãƒ©ã‚°ã‚µãƒ¼ãƒ“ã‚¹ï¼ˆæ–°æ©Ÿèƒ½ã®æ®µéšçš„å±•é–‹åˆ¶å¾¡ï¼‰
const featureFlags = {
  useNewCatalogService: process.env.USE_NEW_CATALOG_SERVICE === 'true',
  useNewCartService: process.env.USE_NEW_CART_SERVICE === 'true'
};

// ãƒ¢ãƒãƒªã‚¹ã¸ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ«ãƒ¼ãƒˆï¼ˆãƒ¬ã‚¬ã‚·ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ï¼‰
const monolithProxy = createProxyMiddleware({
  target: 'http://monolith-app:8080',
  changeOrigin: true,
  pathRewrite: {
    '^/api': '/api'  // ãƒ‘ã‚¹ã‚’ãã®ã¾ã¾ç¶­æŒ
  }
});

// æ–°ã—ã„ã‚«ã‚¿ãƒ­ã‚°ã‚µãƒ¼ãƒ“ã‚¹ã¸ã®ãƒ—ãƒ­ã‚­ã‚·
const catalogServiceProxy = createProxyMiddleware({
  target: 'http://catalog-service:8080',
  changeOrigin: true,
  pathRewrite: {
    '^/api/products': '/products'  // ãƒ‘ã‚¹ã‚’æ›¸ãæ›ãˆ
  }
});

// æ–°ã—ã„ã‚«ãƒ¼ãƒˆã‚µãƒ¼ãƒ“ã‚¹ã¸ã®ãƒ—ãƒ­ã‚­ã‚·
const cartServiceProxy = createProxyMiddleware({
  target: 'http://cart-service:8080',
  changeOrigin: true,
  pathRewrite: {
    '^/api/cart': '/cart'  // ãƒ‘ã‚¹ã‚’æ›¸ãæ›ãˆ
  }
});

// æ©Ÿèƒ½ãƒ•ãƒ©ã‚°ã«åŸºã¥ã„ãŸãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°
if (featureFlags.useNewCatalogService) {
  app.use('/api/products', catalogServiceProxy);
  app.use('/api/categories', catalogServiceProxy);
} 

if (featureFlags.useNewCartService) {
  app.use('/api/cart', cartServiceProxy);
}

// ãã®ä»–ã™ã¹ã¦ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã¯ãƒ¢ãƒãƒªã‚¹ã«è»¢é€
app.use('/api', monolithProxy);

// ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
app.use((err, req, res, next) => {
  console.error('Proxy error:', err);
  res.status(500).json({ error: 'Internal server error' });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`API Gateway listening on port ${PORT}`);
  console.log('Feature flags:', featureFlags);
});
```

### ã‚µãƒ¼ãƒ“ã‚¹ã®æˆç†Ÿåº¦è©•ä¾¡

ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã®å¥å…¨æ€§ã‚’è©•ä¾¡ã™ã‚‹ãŸã‚ã®ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ:

```typescript
// ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹æˆç†Ÿåº¦è©•ä¾¡ã®è‡ªå‹•åŒ–
interface ServiceHealthCheck {
  service: string;
  checks: {
    [checkName: string]: {
      score: number;  // 0-5ã®ã‚¹ã‚³ã‚¢
      details: string;
    };
  };
  overallScore: number; // å¹³å‡ã‚¹ã‚³ã‚¢
  recommendations: string[];
}

// æˆç†Ÿåº¦è©•ä¾¡ã®å®Ÿè¡Œ
async function assessServiceMaturity(serviceName: string): Promise<ServiceHealthCheck> {
  const check: ServiceHealthCheck = {
    service: serviceName,
    checks: {},
    overallScore: 0,
    recommendations: []
  };
  
  // 1. CI/CDæˆç†Ÿåº¦ã®è©•ä¾¡
  const cicdScore = await evaluateCICDMaturity(serviceName);
  check.checks['CICD'] = {
    score: cicdScore.score,
    details: cicdScore.details
  };
  
  if (cicdScore.score < 3) {
    check.recommendations.push(
      'Improve CI/CD pipeline with automated tests and deployments'
    );
  }
  
  // 2. ç›£è¦–ãƒ»å¯è¦³æ¸¬æ€§ã®è©•ä¾¡
  const observabilityScore = await evaluateObservability(serviceName);
  check.checks['Observability'] = {
    score: observabilityScore.score,
    details: observabilityScore.details
  };
  
  if (observabilityScore.score < 3) {
    check.recommendations.push(
      'Enhance monitoring with distributed tracing and business metrics'
    );
  }
  
  // 3. ãƒ¬ã‚¸ãƒªã‚¨ãƒ³ã‚¹è©•ä¾¡
  const resilienceScore = await evaluateResilience(serviceName);
  check.checks['Resilience'] = {
    score: resilienceScore.score,
    details: resilienceScore.details
  };
  
  if (resilienceScore.score < 3) {
    check.recommendations.push(
      'Implement circuit breakers and retry mechanisms for external dependencies'
    );
  }
  
  // 4. ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£è©•ä¾¡
  const scalabilityScore = await evaluateScalability(serviceName);
  check.checks['Scalability'] = {
    score: scalabilityScore.score,
    details: scalabilityScore.details
  };
  
  if (scalabilityScore.score < 3) {
    check.recommendations.push(
      'Improve scaling capabilities with stateless design and caching'
    );
  }
  
  // 5. ã‚³ãƒ¼ãƒ‰å“è³ªè©•ä¾¡
  const codeQualityScore = await evaluateCodeQuality(serviceName);
  check.checks['CodeQuality'] = {
    score: codeQualityScore.score,
    details: codeQualityScore.details
  };
  
  if (codeQualityScore.score < 3) {
    check.recommendations.push(
      'Address technical debt and improve test coverage'
    );
  }
  
  // ç·åˆã‚¹ã‚³ã‚¢ã®è¨ˆç®—
  const totalScore = Object.values(check.checks)
    .reduce((sum, check) => sum + check.score, 0);
    
  check.overallScore = totalScore / Object.keys(check.checks).length;
  
  return check;
}

// è©•ä¾¡çµæœã®ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰è¡¨ç¤º
async function generateMaturityDashboard(): Promise<void> {
  const services = await getServiceList();
  const assessments = await Promise.all(
    services.map(service => assessServiceMaturity(service))
  );
  
  // ç·åˆçš„ãªå¥å…¨æ€§ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã®ç”Ÿæˆ
  renderMaturityDashboard(assessments);
}
```

## ã¾ã¨ã‚

ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã¯ã€å„ªã‚ŒãŸæ‹¡å¼µæ€§ã¨æŸ”è»Ÿæ€§ã‚’æä¾›ã—ã¾ã™ãŒã€ãã®å®Ÿè£…ã¨é‹ç”¨ã«ã¯æ§˜ã€…ãªèª²é¡ŒãŒã‚ã‚Šã¾ã™ã€‚æœ¬è¨˜äº‹ã§ç´¹ä»‹ã—ãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã‚’æ´»ç”¨ã™ã‚‹ã“ã¨ã§ã€ã‚ˆã‚Šå …ç‰¢ã§ä¿å®ˆæ€§ã®é«˜ã„ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã§ãã‚‹ã§ã—ã‚‡ã†ã€‚

2025å¹´ã®ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹é–‹ç™ºã«ãŠã„ã¦ã¯ã€ä»¥ä¸‹ã®ç‚¹ã«ç‰¹ã«æ³¨ç›®ã™ã‚‹ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ï¼š

1. **ãƒ‰ãƒ¡ã‚¤ãƒ³é§†å‹•è¨­è¨ˆã«åŸºã¥ãé©åˆ‡ãªã‚µãƒ¼ãƒ“ã‚¹åˆ†å‰²**
2. **ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®ç©æ¥µçš„ãªæ¡ç”¨**
3. **ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ…é‡ãªé¸æŠã¨å®Ÿè£…**
4. **åŒ…æ‹¬çš„ãªå¯è¦³æ¸¬æ€§ã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³ã®å°å…¥**
5. **éšœå®³å¯¾å¿œã¨å›å¾©åŠ›ã®ãŸã‚ã®ãƒ‘ã‚¿ãƒ¼ãƒ³å®Ÿè£…**
6. **ç¶™ç¶šçš„ãªæ”¹å–„ã¨æˆç†Ÿåº¦è©•ä¾¡**

ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã¯ä¸‡èƒ½ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®è¦æ¨¡ã€ãƒãƒ¼ãƒ æ§‹æˆã€ãƒ“ã‚¸ãƒã‚¹è¦ä»¶ã«å¿œã˜ã¦ã€ãƒ¢ãƒãƒªã‚¹ã¨ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã®ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’æ¤œè¨ã™ã‚‹ã“ã¨ã‚‚é‡è¦ã§ã™ã€‚æœ€çµ‚çš„ã«ã¯ã€ãƒ“ã‚¸ãƒã‚¹ä¾¡å€¤ã®æä¾›ã‚’æœ€å„ªå…ˆã«ã€æŠ€è¡“é¸æŠã‚’è¡Œã„ã¾ã—ã‚‡ã†ã€‚

## å‚è€ƒè³‡æ–™

- [ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ãƒ‘ã‚¿ãƒ¼ãƒ³å®Ÿè·µã‚¬ã‚¤ãƒ‰](https://microservices.io/patterns/index.html)
- [Building Microservices: Designing Fine-Grained Systems](https://www.oreilly.com/library/view/building-microservices-2nd/9781492034018/)
- [Kuberneteså…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://kubernetes.io/docs/home/)
- [OpenTelemetryå…¬å¼ã‚µã‚¤ãƒˆ](https://opentelemetry.io/)
- [Martin Fowlerã®ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹è¨˜äº‹](https://martinfowler.com/articles/microservices.html)